{"ast":null,"code":"/**\n * Utility functions for parsing and handling seat coordinates\n */\n\n/**\n * Parse a string of Vector coordinates in the format <Vector (x, y, z)>\n * @param {string} text - Text containing Vector coordinates, one per line\n * @returns {Array} Array of parsed coordinates objects with x, y, z properties\n */\nexport const parseVectorCoordinates = text => {\n  if (!text) return [];\n  const coordinates = [];\n\n  // Split the text by lines and process each line\n  const lines = text.split('\\n');\n  lines.forEach(line => {\n    line = line.trim();\n    if (!line || !line.includes('<Vector')) return;\n\n    // Extract the coordinates part from the format <Vector (x, y, z)>\n    const match = line.match(/<Vector\\s*\\(([-\\d\\.\\s,]+)\\)>/);\n    if (!match || !match[1]) return;\n\n    // Split the coordinates and convert to numbers\n    const parts = match[1].split(',').map(part => parseFloat(part.trim()));\n    if (parts.length !== 3) return;\n    coordinates.push({\n      x: parts[0],\n      y: parts[1],\n      z: parts[2]\n    });\n  });\n  return coordinates;\n};\n\n/**\n * Convert the parsed vector coordinates to Three.js coordinates\n * @param {Array} coordinates - Array of coordinate objects with x, y, z properties\n * @returns {Array} Array of coordinate objects converted to Three.js coordinate system\n */\nexport const convertToThreeCoordinates = coordinates => {\n  return coordinates.map(coord => ({\n    x: coord.x,\n    y: coord.z,\n    // Vector Y becomes Three.js Z for top-down view\n    z: coord.y // Vector Z becomes Three.js Y for height\n  }));\n};\n\n/**\n * Generate seat data from parsed coordinates\n * @param {Array} coordinates - Array of coordinate objects\n * @returns {Array} Array of seat objects with id, section, row, price, and coordinates\n */\nexport const generateSeatsFromCoordinates = coordinates => {\n  return coordinates.map((coord, index) => {\n    // Determine section based on X coordinate\n    let section = 'A';\n    if (coord.x > 0) {\n      section = 'B';\n    }\n\n    // Simple algorithm to determine row and number based on position\n    const row = Math.floor(Math.abs(coord.y) * 10) % 10 + 1;\n    const number = Math.floor(Math.abs(coord.x) * 10) % 10 + 1;\n\n    // Generate a price based on height (better seats are higher)\n    const height = Math.abs(coord.z);\n    const price = Math.floor(100 + height * 50);\n    return {\n      id: `${section}${row}${number}`,\n      section,\n      row,\n      number,\n      price,\n      coordinates: coord\n    };\n  });\n};\n\n/**\n * Parse a string of coordinates and generate seat data\n * @param {string} text - Text containing Vector coordinates, one per line\n * @returns {Array} Array of seat objects with id, section, row, price, and coordinates\n */\nexport const parseAndGenerateSeats = text => {\n  const parsedCoordinates = parseVectorCoordinates(text);\n  const threeCoordinates = convertToThreeCoordinates(parsedCoordinates);\n  return generateSeatsFromCoordinates(threeCoordinates);\n};\nexport default {\n  parseVectorCoordinates,\n  convertToThreeCoordinates,\n  generateSeatsFromCoordinates,\n  parseAndGenerateSeats\n};","map":{"version":3,"names":["parseVectorCoordinates","text","coordinates","lines","split","forEach","line","trim","includes","match","parts","map","part","parseFloat","length","push","x","y","z","convertToThreeCoordinates","coord","generateSeatsFromCoordinates","index","section","row","Math","floor","abs","number","height","price","id","parseAndGenerateSeats","parsedCoordinates","threeCoordinates"],"sources":["/Users/joshuashunk/Documents/cs131-nerf/src/utils/seatCoordinateParser.js"],"sourcesContent":["/**\n * Utility functions for parsing and handling seat coordinates\n */\n\n/**\n * Parse a string of Vector coordinates in the format <Vector (x, y, z)>\n * @param {string} text - Text containing Vector coordinates, one per line\n * @returns {Array} Array of parsed coordinates objects with x, y, z properties\n */\nexport const parseVectorCoordinates = (text) => {\n  if (!text) return [];\n  \n  const coordinates = [];\n  \n  // Split the text by lines and process each line\n  const lines = text.split('\\n');\n  \n  lines.forEach(line => {\n    line = line.trim();\n    if (!line || !line.includes('<Vector')) return;\n    \n    // Extract the coordinates part from the format <Vector (x, y, z)>\n    const match = line.match(/<Vector\\s*\\(([-\\d\\.\\s,]+)\\)>/);\n    if (!match || !match[1]) return;\n    \n    // Split the coordinates and convert to numbers\n    const parts = match[1].split(',').map(part => parseFloat(part.trim()));\n    if (parts.length !== 3) return;\n    \n    coordinates.push({\n      x: parts[0],\n      y: parts[1],\n      z: parts[2]\n    });\n  });\n  \n  return coordinates;\n};\n\n/**\n * Convert the parsed vector coordinates to Three.js coordinates\n * @param {Array} coordinates - Array of coordinate objects with x, y, z properties\n * @returns {Array} Array of coordinate objects converted to Three.js coordinate system\n */\nexport const convertToThreeCoordinates = (coordinates) => {\n  return coordinates.map(coord => ({\n    x: coord.x,\n    y: coord.z, // Vector Y becomes Three.js Z for top-down view\n    z: coord.y  // Vector Z becomes Three.js Y for height\n  }));\n};\n\n/**\n * Generate seat data from parsed coordinates\n * @param {Array} coordinates - Array of coordinate objects\n * @returns {Array} Array of seat objects with id, section, row, price, and coordinates\n */\nexport const generateSeatsFromCoordinates = (coordinates) => {\n  return coordinates.map((coord, index) => {\n    // Determine section based on X coordinate\n    let section = 'A';\n    if (coord.x > 0) {\n      section = 'B';\n    }\n    \n    // Simple algorithm to determine row and number based on position\n    const row = Math.floor(Math.abs(coord.y) * 10) % 10 + 1;\n    const number = Math.floor(Math.abs(coord.x) * 10) % 10 + 1;\n    \n    // Generate a price based on height (better seats are higher)\n    const height = Math.abs(coord.z);\n    const price = Math.floor(100 + height * 50);\n    \n    return {\n      id: `${section}${row}${number}`,\n      section,\n      row,\n      number,\n      price,\n      coordinates: coord\n    };\n  });\n};\n\n/**\n * Parse a string of coordinates and generate seat data\n * @param {string} text - Text containing Vector coordinates, one per line\n * @returns {Array} Array of seat objects with id, section, row, price, and coordinates\n */\nexport const parseAndGenerateSeats = (text) => {\n  const parsedCoordinates = parseVectorCoordinates(text);\n  const threeCoordinates = convertToThreeCoordinates(parsedCoordinates);\n  return generateSeatsFromCoordinates(threeCoordinates);\n};\n\nexport default {\n  parseVectorCoordinates,\n  convertToThreeCoordinates,\n  generateSeatsFromCoordinates,\n  parseAndGenerateSeats\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}